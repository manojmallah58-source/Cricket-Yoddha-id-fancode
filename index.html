<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Color Sort - Ultra</title>
    <style>
        :root {
            --bg-color: #0f0c29;
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --neon-glow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
            color: white;
        }

        /* --- UI Components --- */
        .header {
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .level-indicator {
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.1s, background 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 45px;
            height: 45px;
        }

        .btn:active { transform: scale(0.9); }
        .btn svg { fill: white; width: 24px; height: 24px; }

        /* --- Game Board --- */
        #game-container {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-content: center;
            gap: 30px 20px;
            max-width: 500px;
            padding: 20px;
            perspective: 1000px;
        }

        .tube {
            width: 60px;
            height: 180px;
            border: 3px solid var(--glass-border);
            border-top: none;
            border-radius: 0 0 30px 30px;
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            box-shadow: inset 0 0 15px rgba(0,0,0,0.5), var(--neon-glow);
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column-reverse;
            overflow: visible; /* Needed for tilting */
        }

        .tube::before { /* Reflection */
            content: '';
            position: absolute;
            top: 10%;
            left: 10%;
            width: 20%;
            height: 80%;
            background: linear-gradient(to right, rgba(255,255,255,0.1), transparent);
            border-radius: 20px;
            pointer-events: none;
        }

        .tube.selected {
            transform: translateY(-20px);
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
        }

        .liquid-layer {
            width: 100%;
            border-radius: 4px;
            transition: height 0.4s ease;
            position: relative;
        }

        /* --- Victory Overlay --- */
        #overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .victory-card {
            background: var(--glass-bg);
            padding: 40px;
            border-radius: 24px;
            border: 1px solid var(--glass-border);
            text-align: center;
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .shake { animation: shake 0.4s; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
    </style>
</head>
<body>

    <div class="header">
        <div class="level-indicator" id="level-text">Level 1</div>
        <div class="controls">
            <div class="btn" onclick="undoMove()" title="Undo">
                <svg viewBox="0 0 24 24"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/></svg>
            </div>
            <div class="btn" onclick="resetLevel()" title="Restart">
                <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
            </div>
        </div>
    </div>

    <div id="game-container"></div>

    <div id="overlay">
        <div class="victory-card">
            <h1 style="margin: 0 0 10px 0; color: #00ffcc;">AWESOME!</h1>
            <p style="margin-bottom: 25px;">Level Completed</p>
            <button class="btn" style="width: 150px; height: 50px; font-weight: bold;" onclick="nextLevel()">NEXT LEVEL</button>
        </div>
    </div>

    <script>
        const COLORS = [
            '#FF355E', '#FD5B78', '#FF6037', '#FF9933', 
            '#FFCC33', '#FFFF66', '#CCFF00', '#66FF66', 
            '#AAF0D1', '#50BFE6', '#FF00CC', '#FF3855'
        ];

        let state = {
            level: 1,
            tubes: [],
            selectedIdx: null,
            history: [],
            isAnimating: false
        };

        const config = {
            maxLayers: 4,
            layerHeight: 42 // pixels
        };

        // --- Sound Engine ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'pop') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'pour') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'win') {
                [523, 659, 783, 1046].forEach((f, i) => {
                    const o = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    o.connect(g); g.connect(audioCtx.destination);
                    o.frequency.value = f;
                    g.gain.setValueAtTime(0, audioCtx.currentTime);
                    g.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + i*0.1);
                    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
                    o.start(); o.stop(audioCtx.currentTime + 0.6);
                });
            }
        }

        // --- Game Logic ---
        function initLevel() {
            state.tubes = [];
            state.history = [];
            state.selectedIdx = null;
            state.isAnimating = false;
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('level-text').innerText = `Level ${state.level}`;

            // Complexity Scaling
            const colorCount = Math.min(3 + Math.floor(state.level / 2), 10);
            const tubeCount = colorCount + (state.level < 5 ? 2 : 3);
            
            const pool = [];
            for (let i = 0; i < colorCount; i++) {
                for (let j = 0; j < config.maxLayers; j++) pool.push(COLORS[i]);
            }
            
            // Shuffle
            for (let i = pool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pool[i], pool[j]] = [pool[j], pool[i]];
            }

            for (let i = 0; i < tubeCount; i++) {
                state.tubes.push(i < colorCount ? pool.splice(0, config.maxLayers) : []);
            }

            render();
        }

        function render() {
            const container = document.getElementById('game-container');
            container.innerHTML = '';
            
            state.tubes.forEach((layers, idx) => {
                const tube = document.createElement('div');
                tube.className = `tube ${state.selectedIdx === idx ? 'selected' : ''}`;
                tube.onclick = () => handleTubeClick(idx);
                
                layers.forEach(color => {
                    const layer = document.createElement('div');
                    layer.className = 'liquid-layer';
                    layer.style.backgroundColor = color;
                    layer.style.height = `${config.layerHeight}px`;
                    tube.appendChild(layer);
                });
                
                container.appendChild(tube);
            });
        }

        async function handleTubeClick(idx) {
            if (state.isAnimating) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            if (state.selectedIdx === null) {
                if (state.tubes[idx].length > 0) {
                    state.selectedIdx = idx;
                    playSound('pop');
                    render();
                }
            } else if (state.selectedIdx === idx) {
                state.selectedIdx = null;
                render();
            } else {
                const sourceIdx = state.selectedIdx;
                const targetIdx = idx;
                
                if (canPour(sourceIdx, targetIdx)) {
                    await pourLiquid(sourceIdx, targetIdx);
                } else {
                    document.querySelectorAll('.tube')[targetIdx].classList.add('shake');
                    setTimeout(() => render(), 400);
                }
                state.selectedIdx = null;
                render();
                checkWin();
            }
        }

        function canPour(sIdx, tIdx) {
            const s = state.tubes[sIdx];
            const t = state.tubes[tIdx];
            if (s.length === 0 || t.length === config.maxLayers) return false;
            if (t.length > 0 && s[s.length-1] !== t[t.length-1]) return false;
            return true;
        }

        async function pourLiquid(sIdx, tIdx) {
            state.history.push(JSON.stringify(state.tubes));
            if (state.history.length > 5) state.history.shift();

            state.isAnimating = true;
            const source = state.tubes[sIdx];
            const target = state.tubes[tIdx];
            const color = source[source.length - 1];
            
            // Calculate how many layers to move
            let count = 0;
            for (let i = source.length - 1; i >= 0; i--) {
                if (source[i] === color && target.length + count < config.maxLayers) {
                    count++;
                } else break;
            }

            // Pouring Animation
            const sourceTubeEl = document.querySelectorAll('.tube')[sIdx];
            const targetTubeEl = document.querySelectorAll('.tube')[tIdx];
            
            // Tilt animation
            const rectS = sourceTubeEl.getBoundingClientRect();
            const rectT = targetTubeEl.getBoundingClientRect();
            const angle = rectT.left < rectS.left ? -75 : 75;
            
            sourceTubeEl.style.zIndex = 50;
            sourceTubeEl.style.transform = `translate(${rectT.left - rectS.left}px, ${rectT.top - rectS.top - 60}px) rotate(${angle}deg)`;

            for (let i = 0; i < count; i++) {
                playSound('pour');
                target.push(source.pop());
                render(); // Partial render to show fluid moving
                await new Promise(r => setTimeout(r, 200));
            }

            sourceTubeEl.style.transform = '';
            await new Promise(r => setTimeout(r, 300));
            state.isAnimating = false;
        }

        function undoMove() {
            if (state.history.length > 0 && !state.isAnimating) {
                state.tubes = JSON.parse(state.history.pop());
                state.selectedIdx = null;
                render();
            }
        }

        function resetLevel() {
            initLevel();
        }

        function checkWin() {
            const isWin = state.tubes.every(tube => 
                tube.length === 0 || (tube.length === config.maxLayers && tube.every(c => c === tube[0]))
            );

            if (isWin) {
                playSound('win');
                setTimeout(() => {
                    document.getElementById('overlay').style.display = 'flex';
                }, 500);
            }
        }

        function nextLevel() {
            state.level++;
            initLevel();
        }

        // Start the game
        initLevel();
    </script>
</body>
</html>


