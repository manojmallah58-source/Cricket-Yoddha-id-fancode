<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Turbo Racer 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87ceeb; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .stats { position: absolute; top: 20px; color: white; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); pointer-events: auto; }
        #score-box { left: 20px; }
        #coin-box { right: 20px; }
        
        #game-over { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: white; padding: 40px; border-radius: 20px;
            text-align: center; display: none; pointer-events: auto;
        }
        button { 
            background: #ff4757; border: none; padding: 15px 30px; color: white; 
            font-size: 20px; border-radius: 10px; cursor: pointer; margin-top: 20px;
        }

        /* Mobile Controls */
        #controls {
            position: absolute; bottom: 30px; width: 100%; display: flex;
            justify-content: space-between; padding: 0 40px; box-sizing: border-box;
        }
        .touch-btn {
            width: 80px; height: 80px; background: rgba(255,255,255,0.3);
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 40px; color: white; user-select: none; pointer-events: auto;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="score-box" class="stats">Score: 0</div>
    <div id="coin-box" class="stats">ðŸª™ <span id="coin-count">0</span></div>
    
    <div id="game-over">
        <h1>GAME OVER</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button onclick="resetGame()">PLAY AGAIN</button>
    </div>

    <div id="controls">
        <div class="touch-btn" id="btn-left">â—€</div>
        <div class="touch-btn" id="btn-right">â–¶</div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

    // --- Configuration ---
    let scene, camera, renderer, player, road, clock;
    let score = 0, coins = 0, isGameOver = false;
    const ROAD_WIDTH = 12;
    const LANE_COUNT = 3;
    const enemyCars = [];
    const collectibles = [];
    const decorObjects = []; // Buildings/Lights
    const laneLines = [];
    
    const keys = { left: false, right: false };

    init();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 20, 100);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 2, -5);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        setupLights();
        createEnvironment();
        createPlayer();
        spawnEnemies();
        spawnCoins();
        setupControls();
        animate();
    }

    function setupLights() {
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(10, 20, 10);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 1024;
        sun.shadow.mapSize.height = 1024;
        scene.add(sun);
    }

    function createEnvironment() {
        // Road
        const roadGeo = new THREE.PlaneGeometry(ROAD_WIDTH, 1000);
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2;
        road.receiveShadow = true;
        scene.add(road);

        // Grass
        const grassGeo = new THREE.PlaneGeometry(200, 1000);
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x2dcf72 });
        const grass = new THREE.Mesh(grassGeo, grassMat);
        grass.rotation.x = -Math.PI / 2;
        grass.position.y = -0.1;
        grass.receiveShadow = true;
        scene.add(grass);

        // Kerbs (Red/White Stripes)
        for (let side of [-1, 1]) {
            const kerbGeo = new THREE.PlaneGeometry(0.5, 1000);
            const kerbMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const kerb = new THREE.Mesh(kerbGeo, kerbMat);
            kerb.rotation.x = -Math.PI / 2;
            kerb.position.set(side * (ROAD_WIDTH / 2 + 0.25), 0.01, 0);
            scene.add(kerb);
        }

        // Scrolling Lane Markings
        for (let i = 0; i < 20; i++) {
            const lineGeo = new THREE.PlaneGeometry(0.2, 3);
            const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const line = new THREE.Mesh(lineGeo, lineMat);
            line.rotation.x = -Math.PI / 2;
            line.position.z = -i * 10;
            line.position.y = 0.02;
            scene.add(line);
            laneLines.push(line);
        }

        // Buildings & Street Lights
        for (let i = 0; i < 10; i++) {
            createDecor(i * -40);
        }
    }

    function createDecor(zPos) {
        // Buildings
        const bColors = [0x555555, 0x777777, 0x444466];
        [-15, 15].forEach(x => {
            const h = 10 + Math.random() * 20;
            const geo = new THREE.BoxGeometry(8, h, 8);
            const mat = new THREE.MeshStandardMaterial({ color: bColors[Math.floor(Math.random()*3)] });
            const b = new THREE.Mesh(geo, mat);
            b.position.set(x, h/2, zPos);
            scene.add(b);
            decorObjects.push(b);
        });

        // Street Lights
        [-7, 7].forEach(x => {
            const pole = new THREE.Mesh(new THREE.BoxGeometry(0.2, 5, 0.2), new THREE.MeshStandardMaterial({color:0x222222}));
            pole.position.set(x, 2.5, zPos + 10);
            scene.add(pole);
            decorObjects.push(pole);
        });
    }

    function createPlayer() {
        const loader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
        loader.setDRACOLoader(dracoLoader);

        // Fallback Placeholder
        const fallbackGeo = new THREE.BoxGeometry(1.5, 0.8, 3);
        const fallbackMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        player = new THREE.Mesh(fallbackGeo, fallbackMat);
        player.position.set(0, 0.5, 0);
        player.castShadow = true;
        scene.add(player);

        loader.load('https://threejs.org/examples/models/gltf/ferrari.glb', (gltf) => {
            scene.remove(player);
            player = gltf.scene;
            player.scale.set(1, 1, 1);
            player.position.set(0, 0, 0);
            player.rotation.y = Math.PI; // Face forward
            
            player.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    if(child.name.includes('body')) child.material.color.set(0xff0000);
                }
            });
            scene.add(player);
        }, undefined, (err) => console.error("Model failed, using fallback"));
    }

    function spawnEnemies() {
        const colors = [0x0000ff, 0x00ff00, 0xffff00, 0x800080];
        for (let i = 0; i < 4; i++) {
            const car = new THREE.Mesh(
                new THREE.BoxGeometry(1.6, 0.8, 3),
                new THREE.MeshStandardMaterial({ color: colors[i] })
            );
            resetEnemy(car);
            scene.add(car);
            enemyCars.push(car);
        }
    }

    function resetEnemy(car) {
        car.position.z = -50 - (Math.random() * 50);
        car.position.x = (Math.random() - 0.5) * (ROAD_WIDTH - 3);
        car.position.y = 0.5;
    }

    function spawnCoins() {
        const coinGeo = new THREE.SphereGeometry(0.4, 16, 16);
        const coinMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
        for (let i = 0; i < 5; i++) {
            const coin = new THREE.Mesh(coinGeo, coinMat);
            resetCoin(coin);
            scene.add(coin);
            collectibles.push(coin);
        }
    }

    function resetCoin(coin) {
        coin.position.z = -30 - (Math.random() * 100);
        coin.position.x = (Math.random() - 0.5) * (ROAD_WIDTH - 2);
        coin.position.y = 0.6;
    }

    function setupControls() {
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') keys.left = true;
            if (e.key === 'ArrowRight') keys.right = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
        });

        // Touch
        const btnL = document.getElementById('btn-left');
        const btnR = document.getElementById('btn-right');
        
        const startLeft = (e) => { e.preventDefault(); keys.left = true; };
        const endLeft = () => keys.left = false;
        const startRight = (e) => { e.preventDefault(); keys.right = true; };
        const endRight = () => keys.right = false;

        btnL.addEventListener('touchstart', startLeft);
        btnL.addEventListener('touchend', endLeft);
        btnR.addEventListener('touchstart', startRight);
        btnR.addEventListener('touchend', endRight);
        
        // Mouse for testing on desktop touch
        btnL.addEventListener('mousedown', startLeft);
        btnL.addEventListener('mouseup', endLeft);
        btnR.addEventListener('mousedown', startRight);
        btnR.addEventListener('mouseup', endRight);
    }

    function updatePhysics(delta) {
        if (isGameOver) return;

        const speed = 40 * delta;
        const moveSpeed = 15 * delta;

        // Player Movement
        if (keys.left && player.position.x > -ROAD_WIDTH/2 + 1) player.position.x -= moveSpeed;
        if (keys.right && player.position.x < ROAD_WIDTH/2 - 1) player.position.x += moveSpeed;

        // Scroll Road Markings
        laneLines.forEach(line => {
            line.position.z += speed;
            if (line.position.z > 10) line.position.z = -100;
        });

        // Scroll Decor
        decorObjects.forEach(obj => {
            obj.position.z += speed;
            if (obj.position.z > 20) obj.position.z -= 400;
        });

        // Update Enemies
        enemyCars.forEach(car => {
            car.position.z += speed * 0.5; // Enemies move slower than relative road speed
            if (car.position.z > 10) resetEnemy(car);

            // Collision Detection
            const playerBox = new THREE.Box3().setFromObject(player);
            const enemyBox = new THREE.Box3().setFromObject(car);
            if (playerBox.intersectsBox(enemyBox)) {
                endGame();
            }
        });

        // Update Coins
        collectibles.forEach(coin => {
            coin.position.z += speed;
            coin.rotation.y += delta * 5;
            if (coin.position.z > 10) resetCoin(coin);

            const playerBox = new THREE.Box3().setFromObject(player);
            const coinBox = new THREE.Box3().setFromObject(coin);
            if (playerBox.intersectsBox(coinBox)) {
                score += 10;
                coins += 1;
                updateUI();
                resetCoin(coin);
            }
        });

        score += Math.floor(delta * 10);
        updateUI();
    }

    function updateUI() {
        document.getElementById('score-box').innerText = `Score: ${score}`;
        document.getElementById('coin-count').innerText = coins;
    }

    function endGame() {
        isGameOver = true;
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('final-score').innerText = score;
    }

    window.resetGame = function() {
        score = 0;
        coins = 0;
        isGameOver = false;
        player.position.x = 0;
        enemyCars.forEach(resetEnemy);
        collectibles.forEach(resetCoin);
        document.getElementById('game-over').style.display = 'none';
        updateUI();
    }

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        updatePhysics(delta);
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>


